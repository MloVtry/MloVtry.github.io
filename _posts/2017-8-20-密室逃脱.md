---
layout: post
title: LUangao&#x5BC6;&#x5BA4;&#x9003;&#x8131;
category : Intro 
tags : [Intro]
---


<link rel="stylesheet" href="/highlight/styles/default.css">
<script src="/highlight/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>


## &#x5BC6;&#x5BA4;&#x9003;&#x8131;
##  &#x9898;&#x76EE;&#x63CF;&#x8FF0;

&#x5373;&#x4F7F;czhou&#x6CA1;&#x6709;&#x6D3E;&#x51FA;&#x6700;&#x5F3A;&#x7BEE;&#x7403;&#x9635;&#x5BB9;&#xFF0C;&#x673A;&#x623F;&#x7BEE;&#x7403;&#x961F;&#x8FD8;&#x662F;&#x66B4;&#x8650;&#x4E86;&#x6821;&#x7BEE;&#x7403;&#x961F;&#x3002;&#x4E3A;&#x4E86;&#x4E0D;&#x6253;&#x51FB;&#x6821;&#x7BEE;&#x7403;&#x961F;&#x4FE1;&#x5FC3;&#xFF0C;czhou&#x51B3;&#x5B9A;&#x6539;&#x53D8;&#x8BAD;&#x7EC3;&#x540E;&#x7684;&#x6D3B;&#x52A8;&#x3002;&#x8FD1;&#x6765;&#xFF0C;&#x6C5F;&#x5927;&#x638C;&#x95E8;&#x7684;&#x5F92;&#x5F1F;&#x5F92;&#x5B59;&#x4EEC;&#x7EB7;&#x7EB7;&#x4E8B;&#x4E1A;&#x6709;&#x6210;&#xFF0C;&#x56DE;&#x5230;&#x6BCD;&#x6821;&#x4E3A;&#x673A;&#x623F;&#x6350;&#x94B1;&#x6350;&#x7269;&#x3002;&#x8D22;&#x5927;&#x6C14;&#x7C97;&#x7684;&#x673A;&#x623F;&#x7EC4;&#x6536;&#x56DE;&#x4E86;&#x4E94;&#x5C42;&#x516D;&#x5C42;&#x7684;&#x6240;&#x6709;&#x6559;&#x5BA4;&#x3002;Czhou&#x51B3;&#x5B9A;&#x5C06;&#x516D;&#x5C42;&#x7684;&#x6559;&#x5BA4;&#x6539;&#x9020;&#x4E3A;&#x667A;&#x80FD;&#x5BC6;&#x5BA4;&#x9003;&#x8131;&#x6D3B;&#x52A8;&#x5BA4;&#x3002;

&#x6BCF;&#x5929;&#x508D;&#x665A;&#xFF0C;&#x795E;&#x725B;&#x4EEC;&#x53EF;&#x4EE5;&#x4F9D;&#x6B21;&#x9010;&#x4E2A;&#x8FDB;&#x5165;&#x6E38;&#x73A9;&#x3002;&#x6211;&#x4EEC;&#x7B80;&#x5355;&#x7684;&#x5C06;&#x6559;&#x5BA4;&#x5206;&#x5272;&#x4E3A;n*n&#x4E2A;&#x623F;&#x95F4;&#xFF0C;K&#x662F;&#x4F60;&#x521D;&#x59CB;&#x6240;&#x5728;&#x623F;&#x95F4;&#xFF0C;T&#x662F;&#x4F60;&#x6700;&#x7EC8;&#x9003;&#x8131;&#x7684;&#x623F;&#x95F4;&#x3002;&#x5982;&#x679C;&#x4F60;&#x60F3;&#x8981;&#x9003;&#x8131;&#x623F;&#x95F4;&#xFF0C;&#x4F60;&#x5FC5;&#x987B;&#x4F9D;&#x6B21;&#x627E;&#x5230;m&#x628A;&#x94A5;&#x5319;&#x3002;&#x6211;&#x4EEC;&#x5047;&#x5B9A;&#x4F60;&#x4ECE;&#x4E00;&#x4E2A;&#x623F;&#x95F4;&#x8FDB;&#x5165;&#x53E6;&#x4E00;&#x4E2A;&#x623F;&#x95F4;&#x9700;&#x8981;&#x82B1;&#x8D39;1&#x7684;&#x65F6;&#x95F4;&#x3002;&#x5F53;&#x7136;&#x67D0;&#x4E9B;&#x623F;&#x95F4;&#x6709;&#x4E9B;&#x7279;&#x6B8A;&#x7684;&#x95EE;&#x9898;(&#x5730;&#x56FE;&#x4E0A;S&#x8868;&#x793A;)&#x9700;&#x8981;&#x56DE;&#x7B54;&#x624D;&#x80FD;&#x901A;&#x8FC7;&#xFF0C;&#x5BF9;&#x4E8E;&#x673A;&#x667A;&#x7684;&#x4F17;&#x725B;&#x4EEC;&#x6765;&#x8BF4;&#xFF0C;&#x8FD9;&#x4E9B;&#x95EE;&#x9898;&#x6839;&#x672C;&#x4E0D;&#x662F;&#x95EE;&#x9898;&#x3002;&#x6211;&#x4EEC;&#x5047;&#x5B9A;&#x4F17;&#x725B;&#x4EEC;&#x82B1;&#x8D39;1&#x7684;&#x65F6;&#x95F4;&#x89E3;&#x51B3;&#x95EE;&#x9898;&#x3002;&#xFF08;&#x4E3B;&#x8981;&#x662F;&#x51FA;&#x9898;&#x7684;&#x4EBA;&#x8868;&#x8FF0;&#x4E0D;&#x6E05;&#xFF0C;&#x5BFC;&#x81F4;&#x4F17;&#x725B;&#x7406;&#x89E3;&#x56F0;&#x96BE;&#xFF1B;&#x5F53;&#x7136;&#x95EE;&#x9898;&#x53EA;&#x9700;&#x8981;&#x56DE;&#x7B54;&#x4E00;&#x6B21;&#xFF0C;&#x4E0B;&#x6B21;&#x518D;&#x6B21;&#x8FDB;&#x5165;&#x623F;&#x95F4;&#x4E0D;&#x9700;&#x8981;&#x56DE;&#x7B54;&#x4E86;&#xFF09;

## &#x8F93;&#x5165;&#x683C;&#x5F0F;

&#x7B2C;&#x4E00;&#x884C;&#x4E24;&#x4E2A;&#x6570;&#x5B57;n&#xFF0C;m

 &#x63A5;&#x4E0B;&#x6765;n*n&#x63CF;&#x8FF0;&#x5730;&#x56FE;
 
## &#x8F93;&#x51FA;&#x683C;&#x5F0F;

&#x9700;&#x8981;&#x6700;&#x5C11;&#x65F6;&#x95F4;&#x9003;&#x8131;&#x5BC6;&#x5BA4;&#x3002;&#x82E5;&#x65E0;&#x89E3;&#x8F93;&#x51FA;impossible

## &#x6570;&#x636E;&#x8303;&#x56F4;&#xFF1A;
    0 < N <= 100, 0<=M<=9&#xFF0C;0<=s<=6

##  &#x601D;&#x8DEF;

##  &#x89E3;&#x6CD5;&#x4E00;

s&#x5F88;&#x5C0F;&#xFF0C;&#x53EF;&#x4EE5;&#x679A;&#x4E3E;s&#x7684;&#x60C5;&#x51B5;&#xFF0C;&#x679A;&#x4E3E;&#x90A3;&#x4E2A;&#x56DE;&#x7B54;&#x4E86;&#xFF0C;&#x90A3;&#x4E2A;&#x4E0D;&#x56DE;&#x7B54;&#xFF0C;&#x628A;&#x7B54;&#x9898;&#x7528;&#x65F6;&#x52A0;&#x4E0A;&#xFF0C;&#x7136;&#x540E;&#x7B54;&#x8FC7;&#x7684;&#x662F;.&#xFF0C;&#x6CA1;&#x7B54;&#x7684;&#x662F;'#'&#xFF0C;&#x7136;&#x540E;&#x505A;&#x4E00;&#x4E2A;bfs
 
```cpp 
#include<iostream>
#include<cstring>
#include<cstdio>
#include<queue>
using namespace std;
int s,sx,sy,tx,ty,ans=673720360;
int n,m;
char map[101][101];
int dis[101][101][10];
int atx[10],aty[10];
int turnx[4]={-1,0,1,0};
int turny[4]={0,1,0,-1};
void turn(int sta)
{
	int it=0;
	for(int i=1;i<=s;++i)
	{
		if(sta&(1<<(i-1)))
		{
			it+=1;
			map[atx[i]][aty[i]]='.';
		}
		else map[atx[i]][aty[i]]='#';
	}
	dis[sx][sy][0]=it;
}
struct node
{
	int x,y,key;
}num[10];
queue<node> q;
bool can(int x,int y,int key)
{
	if(dis[x][y][key]<673720360) return false;
	return true;
}
bool out(int x,int y)
{
	if(x>n||x<1) return true;
	if(y>n||y<1) return true;
	if(map[x][y]=='#') return true;
	return false;
}
int look(int i,int j,int key)
{
	if(map[i][j]>='0'&&map[i][j]<='9')
	{
		int it=map[i][j]-'0';
		if(it==key+1)
		{
			return it;
		}
	}
	return key;
}
void bfs()
{
	q.push((node){sx,sy,0});
	while(!q.empty())
	{
		node now=q.front();q.pop();
		for(int i=0;i<=3;++i)
		{
    		if(out(now.x+turnx[i],now.y+turny[i])) continue;
			int that=look(now.x+turnx[i],now.y+turny[i],now.key);
			if(can(now.x+turnx[i],now.y+turny[i],that))
			{
				dis[now.x+turnx[i]][now.y+turny[i]][that]=dis[now.x][now.y][now.key]+1;
				q.push((node){now.x+turnx[i],now.y+turny[i],that});
			}
		}
	}
}
int main()
{
	freopen("maze.in","r",stdin);
	freopen("maze.out","w",stdout);
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)
	{
		for(int j=1;j<=n;++j)
		{
			cin>>map[i][j];
			if(map[i][j]=='S')
			{
				atx[++s]=i;aty[s]=j;
			}
			if(map[i][j]=='K') sx=i,sy=j;
			if(map[i][j]=='T') tx=i,ty=j;
		}
	}
	int to=(1<<s)-1;
	for(int i=0;i<=to;++i)
	{
		memset(dis,40,sizeof(dis));
		turn(i);
		bfs();
		ans=min(ans,dis[tx][ty][m]);
	}
	if(ans==673720360) printf("impossible");
	else printf("%d",ans);
	return 0;
}
```
 
## &#x89E3;&#x6CD5;&#x4E8C;

&#x72B6;&#x538B;spfa&#xFF0C;&#x4E00;&#x7EF4;&#x8868;&#x793A;&#x6536;&#x96C6;&#x5230;&#x4E86;&#x7B2C;&#x51E0;&#x4E2A;&#x94A5;&#x5319;&#xFF0C;&#x7136;&#x540E;&#x5BF9;&#x56DE;&#x7B54;&#x8FC7;&#x7684;&#x95EE;&#x9898;&#x4E8C;&#x8FDB;&#x5236;&#x538B;&#x4F4D;&#xFF0C;&#x6700;&#x540E;&#x679A;&#x4E3E;&#x5404;&#x4E2A;&#x7B54;&#x9898;&#x72B6;&#x6001;&#x4E0B;&#x7684;&#x91CD;&#x70B9;&#xFF08;&#x7136;&#x800C;&#x67D0;&#x53F0;&#x673A;&#x5B50;&#x5C31;&#x662F;&#x4E0D;&#x7ED9;&#x8FC7;&#xFF0C;&#x6240;&#x4EE5;&#x4EE3;&#x7801;&#x5982;&#x6B64;&#x7684;...&#xFF09;

```cpp 
#include<iostream>
#include<cstring>
#include<vector>
#include<cstdio>
#include<queue>
using namespace std;
int N,M;
char MAP[110][110];
int INF=673720360,SN;
int WHAT[110][110],DIS[110][110][10][150],INIT[110][110][10][150],SX,SY,TX,TY;
int ANS=INF;
struct NODE
{
	int X,Y;
	int K;
	int VIS;
};
queue<NODE> Q;
bool CAN(int X,int Y,int XO,int YO)
{
	if(XO>N||XO<1) return false;
	if(YO>N||YO<1) return false;
	if(MAP[XO][YO]=='#') return false;
}
void SPFA()
{
	memset(DIS,40,sizeof(DIS));
	DIS[SX][SY][0][0]=0;
	Q.push((NODE){SX,SY,0,0});
	INIT[SX][SY][0][0]=1;
	while(!Q.empty())
	{
		NODE NOW=Q.front();
		Q.pop();
		int I=NOW.X,J=NOW.Y;
		INIT[I][J][NOW.K][NOW.VIS]=0;
		if(CAN(NOW.X,NOW.Y,NOW.X+1,NOW.Y))
		{
			int CSOT=1;
			NODE TO=NOW;
			TO.X++;
			if(MAP[I][J]>='0'&&MAP[I][J]<='9')
			{
				int THI=MAP[I][J]-'0';
				if(NOW.K==THI-1) TO.K++;
			}
			if(MAP[I][J]=='S'&&!(TO.VIS&(1<<WHAT[I][J]))) TO.VIS=TO.VIS|(1<<WHAT[I][J]),CSOT++;
			if(DIS[NOW.X][NOW.Y][NOW.K][NOW.VIS]+CSOT<DIS[TO.X][TO.Y][TO.K][TO.VIS])
			{
				DIS[TO.X][TO.Y][TO.K][TO.VIS]=DIS[NOW.X][NOW.Y][NOW.K][NOW.VIS]+CSOT;
				if(!INIT[TO.X][TO.Y][TO.K][TO.VIS])
				{
					INIT[TO.X][TO.Y][TO.K][TO.VIS]=1;
					Q.push(TO);
				}
			}
		}
		if(CAN(NOW.X,NOW.Y,NOW.X-1,NOW.Y))
		{
			int CSOT=1;
			NODE TO=NOW;
			TO.X--;
			if(MAP[I][J]>='0'&&MAP[I][J]<='9')
			{
				int THI=MAP[I][J]-'0';
				if(NOW.K==THI-1) TO.K++;
			}
			if(MAP[I][J]=='S'&&!(TO.VIS&(1<<WHAT[I][J]))) TO.VIS=TO.VIS|(1<<WHAT[I][J]),CSOT++;
			if(DIS[NOW.X][NOW.Y][NOW.K][NOW.VIS]+CSOT<DIS[TO.X][TO.Y][TO.K][TO.VIS])
			{
				DIS[TO.X][TO.Y][TO.K][TO.VIS]=DIS[NOW.X][NOW.Y][NOW.K][NOW.VIS]+CSOT;
				if(!INIT[TO.X][TO.Y][TO.K][TO.VIS])
				{
					INIT[TO.X][TO.Y][TO.K][TO.VIS]=1;
					Q.push(TO);
				}
			}
		}
		if(CAN(NOW.X,NOW.Y,NOW.X,NOW.Y+1))
		{
			int CSOT=1;
			NODE TO=NOW;
			TO.Y++;
			if(MAP[I][J]>='0'&&MAP[I][J]<='9')
			{
				int THI=MAP[I][J]-'0';
				if(NOW.K==THI-1) TO.K++;
			}
			if(MAP[I][J]=='S'&&!(TO.VIS&(1<<WHAT[I][J]))) TO.VIS=TO.VIS|(1<<WHAT[I][J]),CSOT++;
			if(DIS[NOW.X][NOW.Y][NOW.K][NOW.VIS]+CSOT<DIS[TO.X][TO.Y][TO.K][TO.VIS])
			{
				DIS[TO.X][TO.Y][TO.K][TO.VIS]=DIS[NOW.X][NOW.Y][NOW.K][NOW.VIS]+CSOT;
				if(!INIT[TO.X][TO.Y][TO.K][TO.VIS])
				{
					INIT[TO.X][TO.Y][TO.K][TO.VIS]=1;
					Q.push(TO);
				}
			}
		
		}
		if(CAN(NOW.X,NOW.Y,NOW.X,NOW.Y-1))
		{
			int CSOT=1;
			NODE TO=NOW;
			TO.Y--;
			if(MAP[I][J]>='0'&&MAP[I][J]<='9')
			{
				int THI=MAP[I][J]-'0';
				if(NOW.K==THI-1) TO.K++;
			}
			if(MAP[I][J]=='S'&&!(TO.VIS&(1<<WHAT[I][J]))) TO.VIS=TO.VIS|(1<<WHAT[I][J]),CSOT++;
			if(DIS[NOW.X][NOW.Y][NOW.K][NOW.VIS]+CSOT<DIS[TO.X][TO.Y][TO.K][TO.VIS])
			{
				DIS[TO.X][TO.Y][TO.K][TO.VIS]=DIS[NOW.X][NOW.Y][NOW.K][NOW.VIS]+CSOT;
				if(!INIT[TO.X][TO.Y][TO.K][TO.VIS])
				{
					INIT[TO.X][TO.Y][TO.K][TO.VIS]=1;
					Q.push(TO);
				}
			}
		}
	}
}
int main()
{
	freopen("maze.in","r",stdin);
	freopen("maze.out","w",stdout);
	scanf("%d%d",&N,&M);
	for(int I=1;I<=N;++I)
	{
		for(int J=1;J<=N;++J)
		{
			cin>>MAP[I][J];
		    if(MAP[I][J]=='K') SX=I,SY=J;
			if(MAP[I][J]=='T') TX=I,TY=J;
			if(MAP[I][J]=='S') WHAT[I][J]=++SN;
		}
	}
	SPFA();
	int ZZZ=(1<<(SN+1))-1;
	for(int I=0;I<=ZZZ;++I) ANS=min(ANS,DIS[TX][TY][M][I]);
	if(ANS==INF)
	{
		printf("impossible");
		return 0;
	}
	printf("%d",ANS);
	return 0;
}
```
