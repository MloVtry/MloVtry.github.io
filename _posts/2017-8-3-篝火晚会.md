---
layout: post
title: 篝火晚会  
category : Intro 
tags : [intro, tag1, tag2]
---

## Demo Post

水可载舟，亦可赛艇
佳佳刚进高中，在军训的时候，由于佳佳吃苦耐劳，很快得到了教官的赏识，成为了“小教官”。在军训结束的那天晚上，佳佳被命令组织同学们进行篝火晚会。一共有n个同学，编号从1到n。一开始，同学们按照1，2，……，n的顺序坐成一圈，而实际上每个人都有两个最希望相邻的同学。如何下命令调整同学的次序，形成新的一个圈，使之符合同学们的意愿，成为摆在佳佳面前的一大难题。
佳佳可向同学们下达命令，每一个命令的形式如下：
(b1, b2,... bm -1, bm)
这里m的值是由佳佳决定的，每次命令m的值都可以不同。这个命令的作用是移动编号是b1，b2，…… bm的这m个同学的位置。要求b1换到b2的位置上，b2换到b3的位置上，……，要求bm换到b1的位置上。执行每个命令都需要一些代价。我们假定如果一个命令要移动m个人的位置，那么这个命令的代价就是m。我们需要佳佳用最少的总代价实现同学们的意愿，你能帮助佳佳吗？
输入输出格式
输入格式：
输入文件fire.in的第一行是一个整数n（3 <= n <= 50000），表示一共有n个同学。其后n行每行包括两个不同的正整数，以一个空格隔开，分别表示编号是1的同学最希望相邻的两个同学的编号，编号是2的同学最希望相邻的两个同学的编号，……，编号是n的同学最希望相邻的两个同学的编号。
输出格式：
输出文件fire.out包括一行，这一行只包含一个整数，为最小的总代价。如果无论怎么调整都不能符合每个同学的愿望，则输出-1。
对于每个初始状态，都有一（喵喵喵）个目标状态与之对应
那么肯定有一些位置不用移动，也必定有一些位置需要移动
对于需要移动的位置，我们可以设有：
a---->b
那么b，也一定是需要移动的，也就又有：
b---->c
所以对于每个人，一次将他移动到目标位置一定更优，所以说每一个不合法的位置花费都是1
所以ans=n-最多不用移动的元素

什么样的元素不需要移动呢？
因为是一个环 turn to 一个环，肯定是可以通过转动环来使之对应的位置，不必移动
什么样的点，他们是可以对应的呢？肯定是 【与目标状态距离相等】 的点
因为这些点可以不必移动，让其他的点调换，来使他们到达目标位置
所以我们可以先构造出目标状态----有两个
然后统计各个【到目标状态的距离】的点的个数，从中取max，就是最多的不用移动的点的个数
ans=n-Thatmax
#include<iostream>
#include<cstdio>
#include<cstring> 
#define N 50010
using namespace std;
int n,ans;
int a[N],b[N];
int f[N],to[N],js,init[N];
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
	{
		scanf("%d%d",&a[i],&b[i]);
	}
	for(int i=1;i<=n;++i)
	{
		if((a[a[i]]!=i&&b[a[i]]!=i)||(a[b[i]]!=i&&b[b[i]]!=i))
		{
			printf("-1");
			return 0;
		}
	}
	to[1]=1,init[1]=1;
	to[2]=a[1],init[a[1]]=1;
	for(int i=3;i<=n;++i)
	{
		if(!init[a[to[i-1]]])
		{
			to[i]=a[to[i-1]];
			init[a[to[i-1]]]=1;
		}
		else
		{
			to[i]=b[to[i-1]];
			init[b[to[i-1]]]=1;
		}
	}
	for(int i=1;i<=n;++i)
	{
//		cout<<to[i]<<" ";
		f[(to[i]-i+n)%n]++;
	}
//	cout<<endl;
	for(int i=0;i<=n;++i)
	{
		ans=max(ans,f[i]);
	}
	memset(f,0,sizeof(f));
	memset(init,0,sizeof(init));
	
	
	to[1]=1,init[1]=1;
	to[2]=b[1],init[b[1]]=1;
	for(int i=3;i<=n;++i)
	{
		if(!init[a[to[i-1]]])
		{
			to[i]=a[to[i-1]];
			init[a[to[i-1]]]=1;
		}
		else
		{
			to[i]=b[to[i-1]];
			init[b[to[i-1]]]=1;
		}
	}
	for(int i=1;i<=n;++i)
	{
//		cout<<to[i]<<" ";
		f[(to[i]-i+n)%n]++;
	}
//	cout<<endl;
	for(int i=0;i<=n;++i)
	{
		ans=max(ans,f[i]);
	}
	printf("%d",n-ans);
	return 0;
 } 
